/////////////////////////////////////////////////////////////////
//
// Personuppgifter (namn, pnr, epost) på dem som gjort labben
//


/////////////////////////////////////////////////////////////////
//
// 1.1
//
// vad betyder \$* i en makefile? 
	$* avrefererar variablen som lästs in med % (alla eventuella medlemmar)
	och itirerar över all medlemmar i variabeln.

// vad gör -Wall och -g ?
	-Wall ger varning om deklaration av variabler sker i fel ordning. -g
	aktiverar debugg utskrift.

/////////////////////////////////////////////////////////////////
//
// 1.2 a)
// 
// int powerof(int x, int y) {
//     int res = 1;
//     for (int i = 0; i < y; i++); {
//         res *= x;
//     }
//     return res;
// }
// 
// int main() {
//     int x = 10;
//     int y = 3;
// 
//     int res = powerof(x, y);
// 
//     std::cout << x << " upphöjt till " << y << " är " << res << std::endl;
// 
//     float z = 0.29;
//     int w = (int) (z * x * x);
//     if (z * x * x == 29)
//         std::cout << z << "*" << x * x << " är 29" << std::endl;
//     else
//         std::cout << z << "*" << x * x << " är inte 29" << std::endl;           
// }
// 
// Varför blir värdet på variabeln w inte det man tror (0.29*100)? 
	För att w är en int och då avrundas 0.289999*100 till 28 eftersom resten
	slopas.

// Hur många varv körs for-loopen i funktionen powerof? 
	1

// 1.2 b)
//
// int must_follow_a(char * start, int length, char a, char b) {
//     int nr = 0;
//     for (int i = 0; i < length; i++, ++start) {
//         if (*start == a && *(start + 1) == b) // maintainers note: DANGER!
//             nr += 1;
//     }
//     return nr;
// }
// 
// Dina tre testfall
	void test_a_is_second_to_last( void )
    	{
            char vek[] = {'x', 'x', 'a', 'b', 'x'};
            int result = must_follow_a(vek, 4, 'a', 'b');
            TS_ASSERT_EQUALS( result, 1);
    	}

	void test_a_is_third_to_last(void){
		char vek[] = {'x','a','b','a','b'};
		int result = must_follow_a(vek,5,'a','b');
		TS_ASSERT_EQUALS(result,2);
	}

	void test_must_fail(void){
		char vek[] = {'b','b','a','b','b'};
		int result = must_follow_a(vek,3,'a','b');
		TS_ASSERT_EQUALS(result,0);
	}


// Varför är det så viktigt att testa randvillkoren?
Så att man slipper konstiga runtime problem.

/////////////////////////////////////////////////////////////////
//
// 1.3 
// 
// Bifoga källkoden till din version av A.cpp

#include <iostream>
#include <stdio.h>

class A {
public:
    A() 
        {std::cout << "The default contructor" << std::endl; }
    A(const A & ref) 
        {std::cout << "The copy contructor" << std::endl; }
    ~A() 
        {std::cout << "The destructor" << std::endl; }
    A(char * s) 
        {std::cout << "Some other constructor " << s << std::endl;}
    A & operator=(const A & s) 
        {std::cout << "The assignment operator" << std::endl; 
         return *this;}
};

void no_ref(A a) {
	printf("noRefi\n");
}
void with_ref(const A & a) {
	printf("with_ref\n");
}

int main()
{
    A a("my name is a");
    A b = a;         // vad är skillnaden
    A c(a);          // mellan dessa
    A d;             // tre tekniker?
    d = a;

    no_ref(a);       // Bildas temporära objekt?
    with_ref(a);     // Bildas temporära objekt?

    A *aa = new A[5];
    delete aa;       // Vad kommer att hända?
    return 0;
}

// Vad skriver ditt program ut, var förberedd att förklara varför. 
Svarar muntligt

// När frigörs objekten?  
Alla lokala objekt frigörs när main returnerar. 

// När skapas temporära objekt?

//   no_ref(a); 



/////////////////////////////////////////////////////////////////
//
// struct Data {
//     int x, y, z;
// };  
// 
// Data ** foo(Data ** v, int x) {
//     for (int i = 0; i < x; i++)
//         //if (v[i] != 0)
//             v[i] = new Data;
//     return v;
// }
// 
// int main () {
//     const int size = 5;
//     Data ** v = new Data * [size];
//     Data ** p = foo(v, size);
//     delete [] p;
// }

// Hur ser valgrinds felmeddelande ut?  
Memory error

// Blir det någon skillnad i hur mycket minne som läcker när man
// kommenterar if-satsen?
Ja så lägger man ju till en massa data så att den läcker ännu mer minne.

// Borde det ha blivit någon skillnad?
Ja eftersom man lägger till mer saker i arrayen.

// Varför läcker programmet fortfarande minne?
För att man tar bara bort arrayen men inte det den pekar på.

/////////////////////////////////////////////////////////////////
//
// 1.4
//
// Generellt är det ofta en god idé att låta konstruktorer som
// tar ett argument deklareras som explicit. Varför? Ange ett
// exempel där det annars kan bli dumt.
Till exempel om du vill ange en vector Vector v = 5; som har 5 som värde ({5}).
Detta skulle kunna skickas till Default constructorn och då skapa en vector
som är 5 stor {0,0,0,0,0}. Detta undviker man genom att explicit deklarera 
default constructorn.

// operatorn[] måste vara en konstant medlemsfunktion i vissa
// fall. När och varför? Hur kopierar man vektorn?
Man använder det när man vill ha en garanti att en variabel inte ändras i en
funtion. Det garanterar read-only. 
Man kopierar vektorn genom att skapa en ny lista som är lika stor och kopiera 
varje element.

